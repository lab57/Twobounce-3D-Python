        - include("./LoadObj.jl")
        - using .LoadObj
        - using LinearAlgebra
        - using BenchmarkTools
        - 
        - 
        - function getHitLocation(start::Vector{Float64}, dir::Vector{Float64}, t::Float64)
        -     return start + dir * t
        - 
        - end
        - 
        - 
        - function triIntersect(triangle::Vector{Int64}, points::Vector{Vector{Float64}}, start::Vector{Float64}, dir::Vector{Float64})
 55082640     null_intersection::Vector{Float64} = [Inf, Inf, Inf]
        -     eps = 0.000001
        - 
        - 
  4249072     verticies = map((x) -> points[x], triangle)
 10675128     v1, v2, v3 = verticies
  1553168     edge1 = v2 - v1
  1337680     edge2 = v3 - v1
        - 
  1961680     pvec = dir × edge2
 10328936     det = edge1 ⋅ pvec
        - 
  4379744     if (abs(det) < eps)
        0         return false, null_intersection
        -     end
        - 
   985080     inv_det = 1 / det
  1680984     tvec = start - v1
 13173760     u = (tvec ⋅ pvec) * inv_det
        - 
  3891824     if u < 0.0 || u > 1.0  # if not intersection
  3498248         return false, null_intersection
        -     end
        - 
   211432     qvec = tvec × edge1
  1204464     v = dot(dir, qvec) * inv_det
   334936     if v < 0.0 || u + v > 1.0  # if not intersection
        -         #  print('fail3')
   168224         return false, null_intersection
        -     end
        - 
   174568     t = (edge2 ⋅ qvec) * inv_det
    50912     if t < eps
        -         #   print('fail4')
    19088         return false, null_intersection
        -     end
        - 
   443952     return true, [t, u, v]
        - 
        - end
        - 
        - 
        - struct HitInfo
        0     start::Vector{Float64}
        -     vec::Vector{Float64}
        -     t::Float64
        -     obj::Object
        -     tri::Int64
        -     didHit::Bool
        -     u::Float64
        -     v::Float64
        - end
        - 
        - NULLHIT::HitInfo = HitInfo(Vector(), Vector(), 0, Object("null", Vector()), 0, false, 0, 0)
        - 
        - function checkIntersections(data::GeometryData, start::Vector{Float64}, ray::Vector{Float64})::HitInfo
        -     min_t = Inf
        -     u = 0.0
        -     v = 0.0
        -     #hitInfo = HitInfo([], [], 0, [], false, 0, 0)
        -     hit = false
        -     t = 0
        -     tri = 0
   255144     obj = Object("null", Vector())
  1593504     for object in data.objects
        -         #for triangle::Vector{Int64} in data.triangles[object.triangles]
 38385368         for i in 1:length(data.triangles[object.triangles])
110224144             triangle::Vector{Int64} = data.triangles[object.triangles][i]
  9606296             didHit, vec = triIntersect(triangle, data.points, start, ray)
  4272904             if didHit && vec[1] < min_t
     5360                 min_t = vec[1]
        -                 t = min_t
        -                 tri = i #triangle
     7888                 hit = didHit
     7792                 u = vec[2]
    12608                 v = vec[3]
        -                 obj = object
        -             end
        - 
 19498560         end
  2292496     end
        -     #println(obj)
   380728     return HitInfo(start, ray, t, obj, tri, hit, u, v)
        -     #return start, ray, t, obj, tri, hit, u, v
        - end
        - 
        - 
        - function twobounce(data::GeometryData, start::Vector{Float64}, ray::Vector{Float64})::Tuple{HitInfo,HitInfo}
    41680     result::HitInfo = checkIntersections(data, start, ray)
        - 
        - 
        -     nullVector = Vector()
    54880     if !result.didHit
   792360         return (result, NULLHIT)
        -     end
    17808     newStart = getHitLocation(result.start, result.vec, result.t)
        - 
    50768     n = data.points_n[geodata.triangles_n[2]][1]
    77136     p1 = ((2 * ray) ⋅ n / (norm(n) * norm(n)))
     9072     p2 = n * p1
     4912     new_r = ray - p2
        - 
    16384     result2 = checkIntersections(data, newStart, new_r)
        - 
     7200     return result, result2
        - 
        - end
        - 
        - function calcTextureCoordinates(u::Float64, v::Float64, w::Float64, data::Vector{Vector{Float32}})
   126320     coord = [w, u, v]
        -     #result = data ⋅ coord
        - 
    24384     return w * data[1] + u * data[2] + v * data[3]
        - end
        - 
        - function writeToFile(file, data::GeometryData, result::Tuple{HitInfo,HitInfo})
    39696     for i in 1:2
    29632         hit = result[i]
    53744         if !hit.didHit
    12576             return
        -         else
   258552             point_coords = calcTextureCoordinates(hit.u, hit.v, 1 - hit.u - hit.v, data.points_t[data.triangles_t[hit.tri]])
   119064             write(file, "$(hit.obj.name)\t$i\t$(point_coords[1]),$(point_coords[2])\n")
        -         end
    53952     end
        - end
        - function iterateStartVecs(data::GeometryData, n0, n)
        -     outFile = open("testOut.txt", "w")
        -     div = (n - n0) // 7500
        -     Threads.@threads for t in n0:n
        -         start = [0.0, 0.0, 0.0]
        -         θ = rand() * π
        -         ϕ = rand() * 2π
        -         dir = [cos(ϕ) * sin(θ), sin(θ) * sin(ϕ), cos(θ)]
        -         res = twobounce(data, start, dir)
        -         #writeToFile(outFile, data, res)
        -     end
        - 
        - 
        -     close(outFile)
        - 
        - 
        - end
        - 
        - 
        - 
        - @time geodata = loadObj("./FourCubes.obj")
        - println(geodata.objects)
        - println("Loaded")
        - triIntersect(geodata.triangles[1], geodata.points, [0.0, 0.0, 0.0], [1.0, 1.0, 1.0])
        - checkIntersections(geodata, [0.0, 0.0, 0.0], [0.0, 0.0, 0.0])
        - twobounce(geodata, [0.0, 0.0, 0.0], [1.0, 1.0, 1.0])
        - println(geodata.points_n[geodata.triangles_n[2]])
        - @time iterateStartVecs(geodata, 0, 1_000)
